Міністерство освіти і науки України
Харківський національний університет радіоелектроніки



Кафедра ПІ




Звіт з лабораторної роботи №3
з дисципліни «Архітектура програмного забезпечення»




 
Виконав:
ст. гр. ПЗПІ-22-8
Шапаренко Артем Васильович
Перевірив:
ст. викладач каф. ПІ
Сокорчук Ігор Петрович 







Харків 2025  
1 ІСТОРІЯ ЗМІН

У цьому розділі наведено історію внесених змін до документу, що наведено у табл. 1:

Таблиця 1 – Історія змін

№	Дата	Версія	Опис змін та виправлень
1	24.05.2025	0.1	Наведення завдань для виконання до лабораторної роботи
2	24.05.2025	0.1	Формування опису виконаної роботи
3	25.05.2025	0.1	Сформовані результати та висновки
4	27.05.2025	0.1	Сформовані додатки

 
2 ЗАВДАННЯ

Метою цієї лабораторної роботи є розробка сучасного веб-додатку для адміністраторів системи «SeStans». Це окрема адміністративна панель, яка забезпечує зручний інтерфейс для керування ключовими об'єктами системи — користувачами, резерваціями та станціями технічного обслуговування. Через веб-інтерфейс адміністратори можуть виконувати всі стандартні CRUD-операції, контролювати актуальний стан сервісних точок, а також створювати резервні копії бази даних. Функціонал резервного копіювання реалізований як вручну, так і в автоматичному режимі, що дозволяє мінімізувати ризики втрати даних та підвищити загальну надійність системи.
Для захисту доступу до адміністративної частини реалізовано механізм автентифікації на основі пари логін-пароль. Після успішного входу користувач отримує JWT-токен, який використовується для авторизації всіх подальших запитів до серверної частини. Це дозволяє ефективно розмежувати доступ до ресурсоємних операцій і забезпечити безпечну взаємодію між клієнтом і сервером. В результаті створено повноцінний інструмент для технічного та організаційного супроводу системи онлайн-бронювання, який відповідає вимогам сучасної веб-архітектури та дозволяє масштабувати платформу відповідно до зростання навантаження.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Створення графічних матеріалів: діаграм

У процесі реалізації програмної системи «SeStans» було створено набір UML-діаграм, які наочно ілюструють архітектуру, функціональні можливості та логіку взаємодії між компонентами системи. Ці графічні матеріали дозволяють краще зрозуміти структуру системи, поведінку користувачів та основні процеси, що відбуваються у веб-застосунку.

3.1.1 Розробка діаграми компонентів

Було створено діаграму компонентів, яка відображає основні частини програмної системи (Див. рис. Б.1). До основних компонентів відносяться: модуль авторизації (JWT), а також панелі для керування користувачами, станціями, бронюваннями та створення резервної копії бази даних. Кожен з компонентів взаємодіє з відповідними частинами як серверної, так і клієнтської логіки.

3.1.2 Розробка діаграми діяльності

Окремо була створена діаграма діяльності (Див. рис. Б.2). Вона описує основний сценарій використання системи адміністратором: від моменту входу в систему до керування таблицями та створенням резервної копії бази даних. Ця діаграма відображає логічну послідовність кроків та можливі розгалуження дій в інтерфейсі адміністратора.

3.1.3 Розробка діаграми взаємодії

Під час розробки системи була створена діаграма прецедентів (Див. рис. Б.3). На ній зображено актора: адміністратора системи. Діаграма демонструє типові дії, які можуть виконувати адміністратори в межах системи: керування інформацією користувачів, станцій, бронювань та створювати резервні копії бази даних.

3.1.4 Розробка діаграми діяльності

Було створено діаграму взаємодії (Див. рис. Б.4), що ілюструє процеси обміну повідомленнями між адміністратором та системою. Діаграма демонструє логіку дій адміністратора при вході в систему: перегляд інформації; керуванні користувачами, бронюваннями, станціями; створення резервної копії бази даних.

3.2 Розробка веб інтерфейсу адміністратора 

У процесі реалізації системи «SeStans» було створено фронтенд-інтерфейс користувача-адміністратора і доданий захист для серверного API. Основна увага була приділена інтеграції механізму автентифікації та авторизації на базі JWT, що забезпечує контроль доступу до функціоналу системи відповідно до ролей користувачів. Серверна частина реалізована з використанням Spring Boot, а інтерфейс користувача — на базі сучасного технологічного стеку React + Tailwind, що забезпечує швидку роботу та адаптивність на різних пристроях.
Фронтенд-частина реалізована на React. Для стилізації інтерфейсу використано Tailwind CSS, що дозволило швидко створювати адаптивні компоненти. Інтерфейс передбачає форми входу, реєстрації, керування обліковим записом, взаємодію з календарем бронювань, перегляд аналітики та адміністративних звітів. Після авторизації користувач отримує JWT, який зберігається в локальному сховищі браузера й автоматично додається до заголовків запитів, що унеможливлює доступ до даних без відповідних прав.
Для підвищення зручності користування та підтримки багатомовності в інтерфейсі реалізовано механізм інтернаціоналізації з використанням бібліотеки i18next. Всі текстові елементи було винесено до окремих мовних ресурсів, і відповідні переклади реалізовано для української та англійської мов. Переклад динамічних значень, таких як стани або логічні відповіді, також здійснюється через систему локалізації, що забезпечує коректне відображення контенту згідно з вибраною мовою інтерфейсу.
Завдяки реалізованій архітектурі, система повністю відмовилась від використання сесій і зберігання стану на сервері, що дозволяє масштабувати її горизонтально. Крім того, RESTful-підхід до побудови API забезпечив гнучкість у роботі з мобільними або сторонніми клієнтами. Таким чином, розширення системи шляхом додавання нових ролей або зміни прав доступу здійснюється централізовано через конфігурацію безпеки без змін у бізнес-логіці або інтерфейсі користувача. 
4 ВИСНОВКИ

У результаті виконання лабораторної роботи було реалізовано сучасну адміністративну панель для системи «SeStans», що значно підвищила ефективність технічного та організаційного супроводу сервісу онлайн-бронювання. Завдяки впровадженню інтерфейсу для адміністраторів було забезпечено повний контроль над ключовими об'єктами системи — користувачами, резерваціями та станціями технічного обслуговування — із можливістю виконання стандартних CRUD-операцій у зручному веб-інтерфейсі.
Для забезпечення безпеки реалізовано механізм автентифікації на основі JWT, що дозволило організувати захищений обмін даними між клієнтом і сервером та чітко розмежувати права доступу. Завдяки цьому адміністратори можуть безпечно взаємодіяти із системою, не ризикуючи порушити цілісність або конфіденційність даних.
Крім того, було впроваджено функціонал резервного копіювання бази даних — як у ручному, так і в автоматичному режимі. Це дозволяє мінімізувати ризики втрати важливої інформації та забезпечує стабільність роботи системи в довгостроковій перспективі.
Інтерфейс адміністратора створено з використанням технологій React і Tailwind CSS, що забезпечило високу продуктивність, адаптивність та швидку інтеграцію нового функціоналу. Підтримка багатомовності через бібліотеку i18next зробила систему зручною для користувачів із різних мовних середовищ.
 
ДОДАТОК А
Посилання на відеозапис доповіді та текст хронологічного опису доповіді

Відеозапис доповіді на YouTube: https://youtu.be/ENII3nEdVbE  

00:00 Вступ.
00:45 Форма логіну до сайту та демонстрація входу у систему.
01:02 Опис інтерфейсу.
01:44 Демонстрація працездатності перекладу.
02:57 Принцип роботи з даними. Проведення операцій редагування інформації бази даних.
03:27: Демонстрація роботи видалення інформації з бази даних. 
ДОДАТОК Б
Графічні матеріали

 
Рисунок Б.1 – UML діаграма компонентів

 
Рисунок Б.2 – UML діаграма діяльності
 
Рисунок Б.3 – UML діаграма прецедентів

 
Рисунок Б.4 – UML діаграма взаємодії 
Додаток В
Програмний код 

		В.1 Впровадження локалізації

index.js:

GitHub репозиторій: https://github.com/NureShaparenkoArtem/apz-pzpi-22-8-shaparenko-artem/blob/main/Lab3/pzpi-22-8-shaparenko-artem-lab3/FrontEnd/translation/index.js 

1  import i18n from "i18next";
2  import { initReactI18next } from "react-i18next";
3  import translationEn from "./en.json";
4  import translationUk from "./ua.json";

5  i18n
6      .use(initReactI18next)
7      .init({
8          resources: {
9              en: { translation: translationEn },
10             uk: { translation: translationUk },
11         },
12         lng: "en",
13         fallbackLng: "en",
14         interpolation: {
15             escapeValue: false,
16         },
17     });

18 export default i18n;

 
В.2 Реалізація безпечного доступу до даних:

SecurityConfig.java:

GitHub репозиторій: https://github.com/NureShaparenkoArtem/apz-pzpi-22-8-shaparenko-artem/blob/main/Lab3/pzpi-22-8-shaparenko-artem-lab3/JWT/SecurityConfig.java 

1  @Bean
2      public SecurityFilterChain filterChain(HttpSecurity http, JwtAuthFilter 
3  jwtAuthFilter) throws Exception {
4          return http
5                  .csrf(csrf -> csrf.disable())
6                  .authorizeHttpRequests(auth -> auth
7                          .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()
8                          .requestMatchers("/api/v1/auth/login", "/swagger-ui/**", 
9  "/v3/api-docs/**").permitAll() // Разрешить публичный доступ
10                         .requestMatchers("/api/v1/user/**", "/api/v1/stations/**", 
11 "/api/v1/reservations/**", "/api/v1/backup/**").authenticated() // Требовать токен
12                         .anyRequest().authenticated())
13                 .addFilterBefore(jwtAuthFilter, 
14 UsernamePasswordAuthenticationFilter.class)
15                 .sessionManagement(session -> 
16 session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
17                 .build();
18     }

 
В.3 Взаємодія з API

api.js

GitHub репозиторій: https://github.com/NureShaparenkoArtem/apz-pzpi-22-8-shaparenko-artem/blob/main/Lab3/pzpi-22-8-shaparenko-artem-lab3/FrontEnd/api/api.jsx 

1   const API_BASE = "http://localhost:8080/api/v1";

2   const getAuthHeader = () => {
3       const token = localStorage.getItem("token");
4       return token ? { Authorization: `Bearer ${token}` } : {};
5   };

6   export const login = async (username, password) => {
7       const response = await fetch(`${API_BASE}/auth/login`, {
8           method: "POST",
9           headers: {
10              "Content-Type": "application/json",
11          },
12          body: JSON.stringify({ username, password }),
13      });

14      if (!response.ok) {
15          throw new Error("Login failed");
16      }

17      const data = await response.json();
18      localStorage.setItem("token", data.token);
19      return true;
20  };

21  export const fetchUsers = async () => {
22      const response = await fetch(`${API_BASE}/user`, {
23          headers: {
24              ...getAuthHeader(),
25          },
26      });
27      if (!response.ok) {
28          throw new Error(`Failed to fetch users: ${response.status}`);
29      }
30      return response.json();
31  };

32  export const deleteUser = async (id) => {
33      const response = await fetch(`${API_BASE}/user/${id}`, {
34          method: "DELETE",
35          headers: {
36              ...getAuthHeader(),
37          },
38      });
39      if (!response.ok) {
40          throw new Error(`Failed to delete user: ${response.status}`);
41      }
42      return response;
43  };

44  export const fetchStations = async () => {
45      const response = await fetch(`${API_BASE}/stations`, {
46          headers: {
47              ...getAuthHeader(),
48          },
49      });
50      if (!response.ok) {
51          throw new Error(`Failed to fetch stations: ${response.status}`);
52      }
53      return response.json();
54  };

55  export const deleteStation = async (id) => {
56      const response = await fetch(`${API_BASE}/stations/${id}`, {
57          method: "DELETE",
58          headers: {
59              ...getAuthHeader(),
60          },
61      });
62      if (!response.ok) {
63          throw new Error(`Failed to delete station: ${response.status}`);
64      }
65      return response;
66  };

67  export const fetchReservations = async () => {
68      const response = await fetch(`${API_BASE}/reservations`, {
69          headers: {
70              ...getAuthHeader(),
71          },
72      });
73      if (!response.ok) {
74          throw new Error(`Failed to fetch reservations: ${response.status}`);
75      }
76      return response.json();
77  };

78  export const deleteReservation = async (id) => {
79      const response = await fetch(`${API_BASE}/reservations/${id}`, {
80          method: "DELETE",
81          headers: {
82              ...getAuthHeader(),
83          },
84      });
85      if (!response.ok) {
86          throw new Error(`Failed to delete reservation: ${response.status}`);
87      }
88      return response;
89  };

90  export const createBackup = async () => {
91      const response = await fetch(`${API_BASE}/backup`, {
92          method: "POST",
93          headers: {
94              ...getAuthHeader(),
95          },
96      });
97      if (!response.ok) {
98          throw new Error(`Failed to create backup: ${response.status}`);
99      }
100     return response.text();
101 };

102 export const updateUser = async (id, updatedData) => {
103     const params = new URLSearchParams({
104         email: updatedData.email,
105         phone: updatedData.phone,
106     });

107     const response = await 
108 fetch(`${API_BASE}/user/updateUserByAdmin/${id}?${params.toString()}`, {
109         method: "PUT",
110         headers: {
111             ...getAuthHeader(),
112         },
113     });

114     if (!response.ok) {
115         throw new Error(`Failed to update user: ${response.status}`);
116     }

117     return response.json();
118 };

119 export const updateStation = async (id, updatedData) => {
120     const params = new URLSearchParams({
121         station_name: updatedData.station_name,
122         location: updatedData.location,
123     });

124     const response = await 
125 fetch(`${API_BASE}/stations/updateStationByAdmin/${id}?${params.toString()}`, {
126         method: "PUT",
127         headers: {
128             ...getAuthHeader(),
129         },
130     });

131     if (!response.ok) {
132         throw new Error(`Failed to update station: ${response.status}`);
133     }

134     return response.json();
135 };




